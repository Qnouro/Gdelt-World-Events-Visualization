<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<style type="text/css" media="screen, print">

		</style>

		<title>World Events visualization</title>
	</head>
	<body>
		<h2 id="h2" align="center"></h2>

		<script src="../d3.js"></script>
		<script src="//d3js.org/d3.v4.min.js"></script>
    <div>
      <select id="selectButton"></select>

      <div id="svg">

      </div>

    </div>
    <div id="my_dataviz"></div>
		<script>

    const width = window.innerWidth * 0.95,
          height = window.innerHeight * 0.90,
          colors = ['#d4eac7', '#c6e3b5', '#b7dda2', '#a9d68f', '#9bcf7d', '#8cc86a', '#7ec157', '#77be4e', '#70ba45', '#65a83e', '#599537', '#4e8230', '#437029', '#385d22', '#2d4a1c', '#223815'];


    let svg = d3.select("#my_dataviz").append('svg')
                  .attr('width', width)
                  .attr('height', height)
                  .attr("viewBox", [0, 0, width, height])
                  .attr("id", "container");



    // Creating the world map

    const projection = d3.geoNaturalEarth1()
    .scale(1)
    .translate([0, 0]);

    const path = d3.geoPath()
        .pointRadius(2)
        .projection(projection);

    const cGroup = svg.append("g");

    // Getting the date, for updating reasons
    var date_var = new Date();
    var last_day = date_var.getDate();


    // -1- Create a tooltip div that is hidden by default:
    var tooltip = d3.select("#my_dataviz")
                    .append("div")
                    .style("opacity", 1)
                    .attr("class", "tooltip")
                    .attr("top", svg.offsetTop + 900 + "px")
                    .attr("left", svg.offsetLeft + 200 + "px")
                    .style("background-color", "black")
                    .style("border-radius", "5px")
                    .style("padding", "10px")
                    .style("color", "white")


    d3.json("world-countries-no-antartica.json", function(values){

        const geojson = values;

        var b  = path.bounds(geojson),
            s = 1 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height),
            t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2];


        projection
            .scale(s)
            .translate(t);


        cGroup.selectAll("path")
            .data(geojson.features)
            .enter()
            .append("path")
            .attr("d", path)
            .attr("id", d => "code" + d.id)
            .attr("class", "country");


        // Handling data


        var allGroup = ["Killed", "Protests", "Affects"]

        d3.select("#selectButton")
          .selectAll('myOptions')
          .data(allGroup)
          .enter()
          .append('option')
          .text(function (d) { return d; }) // text showed in the menu
          .attr("value", function (d) { return d; }) // corresponding value returned by the button

        let eventTypeMap = new Map()

        eventTypeMap["Killed"] = "KILL"
        eventTypeMap["Protests"] = "PROTEST"
        eventTypeMap["Affects"] = "AFFECT"

        let eventColorMap = new Map()

        eventColorMap["KILL"] = "#E71C23"
        eventColorMap["PROTEST"] = "#F4C724"
        eventColorMap["AFFECT"] = "#26ae60"

        var logScale = d3.scaleLog()
                  .base(Math.E)
                  .domain([1, Math.exp(9)])
                  .range([0.5, 4]);

        var year = date_var.getFullYear().toString(),
            month = (date_var.getMonth() + 1).toString(),
            day = date_var.getDate().toString();

        if (day < 10){
          day = "0" + day;
        }

        if (month < 10){
          month = "0" + month;
        }

        var csv_name = year + month + day;

        var name = "20201005"

        name = "new_format"

        function plotData() {
          d3.csv(`${name}.csv`, function(data){

              var current_day = date_var.getDate();

              var selectedOption = d3.select("#selectButton").property("value")


              var eventType = eventTypeMap[selectedOption]


              function handleMouseOver(d, i) {  // Add interactivity


                  var event_str = d.event.charAt(0).toUpperCase() + d.event.slice(1).toLowerCase()
                  event_str = event_str + ":" + d.event_importance[0]

                  tooltip
                    .transition()
                    .duration(200)
                  tooltip
                    .style("opacity", 1)
                    .html(event_str)
                    .style("left", (d3.mouse(this)[0]+30) + "px")
                    .style("top", (d3.mouse(this)[1]+15) + "px")


                  // Use D3 to select element, change color and size
                  d3.select(this)
                    .transition()
                    .duration(200)
                    .ease(d3.easeLinear)
                      .attr("r", logScale(d3.max(d.event_importance)) * 1.5 );

              }  // HandleMouseOver

              function handleMouseOut(d, i) {
                // Use D3 to select element, change color back to normal
                d3.select(this)
                .transition()
                .duration(200)
                .ease(d3.easeLinear)
                  .attr("r", logScale(d3.max(d.event_importance)) * 1);

                tooltip
                  .transition()
                  .duration(200)
                tooltip
                  .style("opacity", 0)

              }  // HandleMouseOut



              var circles = svg.selectAll("circles")
                          .data(data)
                          .enter()
                          .filter(function(d){
                            d.event_importance = eval(d.event_importance)  // Casting string representing array to array of ints

                            // Removing absent latitudes and longitudes
                            if (d.event_latitude == "" || d.event_longitude == ""){
                              return false;
                            }

                            if (d.event == eventTypeMap[selectedOption]){
                              return true;
                            }

                            return false;})
                          .append("circle")
                          .attr("r", function(d){

                            return (logScale(d3.max(d.event_importance)) / 4);
                          })
                          .attr("transform", function(d) {
                            return "translate(" + projection([
                              (d.event_longitude),
                              (d.event_latitude)
                            ]) + ")";
                          })
                          .style("opacity", 0.0)
                          .style("fill", function(d){
                              return eventColorMap[d.event]
                          })
                          .on("mouseover", handleMouseOver)
                          .on("mouseout", handleMouseOut);


          svg.selectAll('circle')
                  .transition()
                  .duration(1000)
                  .ease(d3.easeLinear)
                  .attr("r", function(d){
                    return logScale(d3.max(d.event_importance));
                  })
                  .style("opacity", 1);


          // name = "20201006"

          });  // data
        };  // plotData

        function removeData() {
          svg.selectAll('circle')
                  .transition()
                  .duration(1000)
                  .ease(d3.easeLinear)
                  .attr("r", function(d){
                    return logScale(d.event_importance);
                  })
                  .style("opacity", 0.0);
          svg.selectAll('circle')
             .remove()
        };  // removeData

        plotData()
        var inter = setInterval(function() {
                    plotData();
                  }, 60000);



        d3.select("#selectButton").on("change", function(d) {
            console.log("Clicked!")
            // name = "20201005"
            removeData()
            plotData()
        });

    });  // world map

		</script>
	</body>
</html>
